from tkinter import *
from tkinter.colorchooser import askcolor
import copy

def __init__(app, root, canvas):
    app.board = Board(app)
    app.brush = Brush(app)
    app.activeButton = None
    app.blendingTool = BlendingTool()
    app.eraser = Eraser() 
    app.magicWand = MagicWand()

    app.brushButton = Button(root, text='brush', command = lambda:useBrush(app))
    app.brushButton.pack()

    app.penButton = Button(root, text='pen', command = lambda:usePen(app))
    app.penButton.pack()

    app.magicWandButton = Button(root, text='Magic Wand', 
        command = lambda:useMagicWand(app))
    app.magicWandButton.pack()

    app.resetButton = Button(root, text='reset', command = lambda:resetBoard(app, canvas))
    app.resetButton.pack()

    app.changeColorButton = Button(root, text='change color', command = lambda:chooseColor(app))
    app.changeColorButton.pack()

    # app.changeSizeButton = Scale(root, from_=1, to=30, orient=HORIZONTAL)
    # app.changeSizeButton.set(2)
    # app.changeSizeButton.pack()

    app.mouseDown = False   
    app.mouseDrag = False

def changeSize(app):
    if app.activeButton == 'brush':
        app.brush.brushRadius = app.changeSizeButton.get()

def chooseColor(app):
    app.brush.hexColor = askcolor()[1]
    print(app.brush.hexColor)

def resetBoard(app, canvas):
    app.board = Board(app)
    app.brush.pointNum=0
    canvas.delete("all")
    app.mouseDrag = False
    app.mouseDown = False

def useBrush(app):
    app.activeButton = 'brush'
    app.brush.brushRadius = 20

def usePen(app):
    app.activeButton = 'brush'
    app.brush.brushRadius = 1

def useMagicWand(app):
    app.moveObject = False
    app.magicWand = MagicWand()
    app.activeButton = 'magicWand'


def mouseDragged(app, event, canvas):
    if app.activeButton == 'brush':
        app.brush.cx, app.brush.cy = event.x, event.y
    elif app.activeButton == 'magicWand':
        app.magicWand.cx, app.magicWand.cy = event.x, event.y
        if app.magicWand.isEnclosed and ((event.y,event.x) in app.magicWand.moveAreaSet):
            app.moveObject = True
            
            print("moving")
    app.mouseDrag = True

# def mousePressed(app, event):
#     if app.activeButton == 'brush':
#         app.brush.cx, app.brush.cy = event.x, event.y
#         app.board.updateBoard(app)
#     elif app.activeButton == 'magicWand':
#         app.magicWand.cx, app.magicWand.cy = event.x, event.y
#         app.board.updateBoard(app)

#     app.mouseDown = True

def drawAll(app, canvas, event):
    # changeSize(app)
    if app.activeButton == 'brush':
        if app.mouseDown or app.mouseDrag:
            app.brush.draw(event, canvas)
            app.board.updateBoard(app, canvas)
    elif app.activeButton == 'magicWand':
        if app.magicWand.isEnclosed == False:
            if app.mouseDown or app.mouseDrag:
                app.magicWand.draw(event, canvas)
                app.board.updateBoard(app, canvas)
        elif app.magicWand.isEnclosed and app.moveObject == True:
            app.magicWand.moveArea(app, event, canvas)
            #r = app.brush.brushRadius//2
            # for row in range(len(app.board.boardList)):
            #     for col in range(len(app.board.boardList[0])):
            #         if 'brush' in app.board.boardList[row][col]: 
            #             canvas.create_oval(col, row, 
            #                 col, row, fill = app.board.boardList[row][col][0])
            startPointCoords = app.magicWand.drawnPointsInArea[0][1][2]
            startPoint = app.magicWand.drawnPointsInArea[0][0]
            # skipPoint = False
            for point in range(1,len(app.magicWand.drawnPointsInArea)):
                # if skipPoint==True:
                #     skipPoint = False
                #     continue
                # else:
                if point == startPoint+1:
                    coords = app.magicWand.drawnPointsInArea[point][1][2]
                    canvas.create_line(startPointCoords[0], startPointCoords[1], coords[0], coords[1],
                        fill = app.magicWand.drawnPointsInArea[point][1][0], 
                        width = app.magicWand.drawnPointsInArea[point][1][3],
                        capstyle=ROUND, smooth = TRUE, splinesteps = 100)
                    startPoint = point
                    startPointCoords = coords
                else:
                    startPoint = point
                    startPointCoords = app.magicWand.drawnPointsInArea[point][1][2]
                    # skipPoint = True

class Board(object):
    def __init__(self, app):
        self.rgbColor = (255,255,255)
        self.hexColor = "#%02x%02x%02x" % self.rgbColor
        self.defaultColor = "#%02x%02x%02x" % (255,255,255)

        self.rows = app.width
        self.cols = app.height
        self.boardList = [[[self.hexColor,'board'] for j in range(self.cols)] for i in range(self.rows)]
        # for row in range(self.rows):
        #     for col in range(self.cols):
        #         self.boardList[row][col] = [self.hexColor, 'board']

    def fillBackgroundColor(self, color):
        pass

    def updateBoard(self, app, canvas):
        if app.activeButton == 'brush':
            x,y = app.brush.cx, app.brush.cy
            r = app.brush.brushRadius
            
            for row in range(y-(r//2), y+(r//2)+1):
                for col in range(x-(r//2), x+(r//2)+1):
                    app.brush.pointNum+=1
                    app.board.boardList[row][col] = [app.brush.hexColor, 'brush', (col, row), app.brush.pointNum, r]
                    print(row,col, app.board.boardList[row][col])
        
        if app.activeButton == 'magicWand' and app.magicWand.isEnclosed == False:
            x,y = app.magicWand.cx, app.magicWand.cy
            r = app.magicWand.brushRadius
            app.board.boardList[y][x].append('magicWand')
            print(app.board.boardList[y][x])
            app.magicWand.selectArea(x, y, app.board.boardList, canvas)

class Brush(object):
    def __init__(self, app):
        self.rgbColor = (0,0,0)

        #CITATION: hex conversion code from https://stackoverflow.com/a/41384190
        self.hexColor = "#%02x%02x%02x" % self.rgbColor

        self.texture = 'pen'
        #self.brushSize = app.brushSize
        self.brushRadius = 1

        self.pointNum = 0

        self.cx = None
        self.cy = None
        self.oldX = None
        self.oldY = None

    def changeColor(self, color):
        pass

    # def changeSize(self):
    #     self.brushRadius = changeSize(app)

    def changeTexture(self, texture):
        pass

    def draw(self, event, canvas):
        canvas.create_line(self.cx, self.cy, event.x, event.y,
                            width=self.brushRadius, fill=self.hexColor,
                            capstyle=ROUND, smooth = TRUE, splinesteps = 100)
        self.cx, self.cy = event.x, event.y

    # def draw(self, canvas):
    #     canvas.create_oval(self.cx+self.r, self.cy+self.r, 
    #         self.cx-self.r, self.cy-self.r, fill = self.hexColor)

class BlendingTool(object):
    def __init__(self):
        self.cx = None
        self.cy = None

    def blendColors(self):
        pass

class Eraser(object):
    def __init__(self):
        self.brushSize = None
        self.cx = None
        self.cy = None
        self.r = None

    def erase(self):
        pass

    def changeSize(self):
        pass

class MagicWand(object):
    def __init__(self):
        self.brushRadius = 1
        self.isEnclosed = False
        self.selectedAreaSet = set()
        self.moveAreaSet = set()
        self.cx = None 
        self.cy = None
        self.boardList = None
        self.defaultColor = "#%02x%02x%02x" % (255,255,255)
        self.drawnPointsInArea = None

    def selectArea(self, cx, cy, boardList, canvas):
        if not self.isEnclosed:
            if (cx,cy) in self.selectedAreaSet:
                self.boardList = boardList
                self.defineSelectedAreaBounds(canvas)
                self.isEnclosed = True
                self.findDrawnPointsInSelectedArea()
                print('ENCLOSED')
            else:
                self.selectedAreaSet.add((cx,cy))

    def defineSelectedAreaBounds(self, canvas):
        bounds = []

        selectedRows = []
        for row in range(len(self.boardList)):
            for col in range(len(self.boardList[0])):
                if 'magicWand' in self.boardList[row][col]:
                    selectedRows.append(row)
        self.minRow = min(selectedRows)
        self.maxRow = max(selectedRows)

        self.colBounds = []
        for row in range(self.minRow, self.maxRow+1):
            selectedCols = []
            for col in range(len(self.boardList[0])):
                if 'magicWand' in self.boardList[row][col]:
                    selectedCols.append(col)
            if len(selectedCols)<=1:
                self.colBounds.append(self.colBounds[-1])
            else:
                minCol = min(selectedCols)
                maxCol = max(selectedCols)
                self.colBounds.append((minCol, maxCol))

        index = 0
        for row in range(self.minRow,self.maxRow+1):
            for col in range(self.colBounds[index][0], self.colBounds[index][1]):
                self.boardList[row][col].append('selected')
                print(self.boardList[row][col])
                self.moveAreaSet.add((row,col))
            index+=1
        #self.testDraw(canvas)
        
    def testDraw(self, canvas):
        index = 0
        for row in range(self.minRow,self.maxRow+1):
#            for col in range(self.colBounds[index][0], self.colBounds[index][1]):
            canvas.create_line(self.colBounds[index][0], row, self.colBounds[index][1], row, fill = self.defaultColor)
            index+=1

    def moveArea(self, app, event, canvas):
        x,y = self.cx, self.cy
        distX = event.x-x
        distY = event.y-y
        # self.newBoard = [[[self.defaultColor,'board'] for j in range(len(self.boardList[0]))] for i in range(len(self.boardList))]
        # self.testDraw(canvas)
        # for row in range(len(self.boardList)):
        #     for col in range(len(self.boardList[0])):
        #         if (('selected' in self.boardList[row][col]) and 
        #             ('brush' in self.boardList[row][col])):
        #             self.newBoard[row+distY][col+distX] = self.boardList[row][col]
        for point in range(len(self.drawnPointsInArea)):
            coords = self.drawnPointsInArea[point][1][2]
            xCoord, yCoord = coords[0], coords[1]
            self.drawnPointsInArea[point][1][2] = (xCoord+distX, yCoord+distY)

        self.cx = event.x
        self.cy = event.y

    def findDrawnPointsInSelectedArea(self):
        pointDict = dict()
        for row in range(len(self.boardList)):
            for col in range(len(self.boardList[0])):
                if 'selected' in self.boardList[row][col] and 'brush' in self.boardList[row][col]:
                    tempList = copy.deepcopy(self.boardList[row][col])
                    pointNum = self.boardList[row][col][3]
                    pointDict[pointNum] = tempList[:3] + tempList[4:]
        self.drawnPointsInArea = sorted(list(pointDict.items()))
        print(self.drawnPointsInArea)

    def mirrorSelectedArea(self):
        pass

    def draw(self, event, canvas):
        canvas.create_line(self.cx, self.cy, event.x, event.y,
                    width=self.brushRadius, fill='red',
                    capstyle=ROUND, smooth = TRUE, splinesteps = 100)

        self.cx, self.cy = event.x, event.y

#CITATION: adapted basic Tkinter setup from http://www.krivers.net/15112-f18/notes/notes-oopy-animation.html
def run(width=300, height=300):
    def drawAllWrapper(app, canvas, event):
        drawAll(app, canvas, event)

    def mousePressedWrapper(app, event, canvas):
        #mousePressed(app, event)
        mouseDragged(app, event, canvas)

# Set up data and call init
    class Struct(object): pass
    app = Struct()
    app.width = width
    app.height = height

    # create the root
    root = Tk()
    root.resizable(width=False, height=False) # prevents resizing window

    # create the canvas
    canvas = Canvas(root, width=app.width, height=app.height)
    canvas.configure(bd=0, highlightthickness=0)
    canvas.pack()

  # set up events
    root.bind("<Button-1>", lambda event:
                            mousePressedWrapper(app, event, canvas))
    root.bind('<B1-Motion>', lambda event:
                            drawAllWrapper(app, canvas, event))

    __init__(app, root, canvas)

    # launch the app
    root.mainloop()  # blocks until window is closed
    print("bye!")

run(500, 500)